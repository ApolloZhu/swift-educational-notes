<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Swift 错误诊断教育性注释</title><link>/swift-educational-notes/post/</link><description>Recent content in Posts on Swift 错误诊断教育性注释</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2020 &lt;a href=https://Apollonyan.github.io>Apollo Zhu &amp; Apollonyan&lt;/a></copyright><lastBuildDate>Mon, 02 Mar 2020 03:21:08 +0000</lastBuildDate><atom:link href="/swift-educational-notes/post/index.xml" rel="self" type="application/rss+xml"/><item><title>使用要求带有 `Self` 或关联类型的协议</title><link>/swift-educational-notes/associated-type-requirements/</link><pubDate>Mon, 02 Mar 2020 03:21:08 +0000</pubDate><guid>/swift-educational-notes/associated-type-requirements/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>诊断名称&lt;/th>
&lt;th>错误信息&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>unsupported_&lt;wbr>existential_&lt;wbr>type&lt;/code>&lt;/td>
&lt;td>protocol &lt;code>X&lt;/code> can only be used as a generic constraint because it has &lt;code>Self&lt;/code> or associated type requirements&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description><content:encoded><![CDATA[<p>在 Swift 语言中，协议可以被用作类型，作为泛型约束，又或是不透明类型的一部分：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// CustomStringConvertible 可以被用作一个类型，</span>
<span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">:</span> <span class="n">CustomStringConvertible</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="c1">// ……或作为对泛型 &#39;T&#39; 的约束，</span>
<span class="kd">func</span> <span class="nf">bar</span><span class="p">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">CustomStringConvertible</span><span class="p">&gt;(</span><span class="n">baz</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="c1">// ……或作为不透明类型的一部分。</span>
<span class="kd">func</span> <span class="nf">baz</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">CustomStringConvertible</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</code></pre></div><p>虽然 Swift 中所有的协议都可以被用作泛型约束以及不透明类型的一部分，但并不是所有的协议都能被用作类型。准确地说，如果一个协议的要求中使用了 <code>Self</code> 或者关联类型，那么它就不能被作为类型使用。<code>Identifiable</code> 就是这样的一个例子：其 <code>var id: ID { get }</code> 这个要求使用了关联类型 <code>ID</code>。因此，下面这段代码是无法编译的：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">:</span> <span class="n">Identifiable</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="c1">// error: protocol &#39;Identifiable&#39; can only be used as a generic constraint because it has Self or associated type requirements</span>
</code></pre></div><p>之所以像 <code>Identifiable</code> 这样要求使用 <code>Self</code> 或者关联类型的协议不能被用作类型，是因为那样的类型实际上一般并没有什么用处。对于 <code>var id: ID { get }</code> 这样有 <code>Self</code> 或者关联类型的要求，既然我们并不知道其中的关联类型具体是什么，那自然也就无法使用。</p>
<p>在处理被 <code>Self</code> 或者关联类型要求约束的泛型协议时，使用不透明类型或者自己实现类型擦除能解决大多数的问题。欲知详情，请参阅《The Swift Programming Language》中 <a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/21_protocols"target="_blank">协议</a>、<a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/22_generics"target="_blank">泛型</a> 和 <a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/23_opaque_types"target="_blank">不透明类型</a> 这些章节。</p>
]]></content:encoded></item><item><title>属性包装器的实现要求</title><link>/swift-educational-notes/property-wrapper-requirements/</link><pubDate>Fri, 28 Feb 2020 04:00:06 +0000</pubDate><guid>/swift-educational-notes/property-wrapper-requirements/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>诊断名称&lt;/th>
&lt;th>错误信息&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>property_wrapper_&lt;wbr>no_&lt;wbr>value_&lt;wbr>property&lt;/code>&lt;/td>
&lt;td>property wrapper type &lt;code>X&lt;/code> does not contain a non-static property named &lt;code>Y&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>property_wrapper_&lt;wbr>wrong_&lt;wbr>initial_&lt;wbr>value_&lt;wbr>init&lt;/code>&lt;/td>
&lt;td>&lt;code>X&lt;/code> parameter type (&lt;code>Y&lt;/code>) must be the same as its &lt;code>wrappedValue&lt;/code> property type &lt;code>Z&lt;/code> or an &lt;code>@autoclosure&lt;/code> thereof&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>property_wrapper_&lt;wbr>failable_&lt;wbr>init&lt;/code>&lt;/td>
&lt;td>property wrapper initializer &lt;code>X&lt;/code> cannot be failable&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>property_wrapper_&lt;wbr>type_&lt;wbr>requirement_&lt;wbr>not_&lt;wbr>accessible&lt;/code>&lt;/td>
&lt;td>[&lt;code>private&lt;/code>/&lt;code>fileprivate&lt;/code>/&lt;code>internal&lt;/code>/&lt;code>public&lt;/code>/&lt;code>open&lt;/code>] &lt;code>XXX Y&lt;/code> cannot have more restrictive access than its enclosing property wrapper type &lt;code>Z&lt;/code> (which is [&lt;code>private&lt;/code>/&lt;code>fileprivate&lt;/code>/&lt;code>internal&lt;/code>/&lt;code>public&lt;/code>/&lt;code>open&lt;/code>])&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description><content:encoded><![CDATA[<p>如果用修饰符<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> <code>@propertyWrapper</code> 标记一个类型，那它还必须满足一定的条件才会是有效的属性包装器。</p>
<p>首先，所有的属性包装器类型都必须要有一个叫做 <code>wrappedValue</code> 的属性。这个属性不能是静态的，而且至少要有和属性包装器类型相同的访问级别。属性包装器的 <code>projectedValue</code> 属性（如果有的话）也会受到如此限制。</p>
<p>其次，属性包装器不能有可失败的构造器<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。另外，如果属性包装器的构造器有一个 <code>wrappedValue</code> 参数，那这个参数的类型必须和属性 <code>wrappedValue</code> 的类型相同，又或者是返回那个类型的 <code>@autoclosure</code>。</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>attribute，又译作“特性”。 <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>initializer，又译作“初始化器”。 <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>`@dynamicCallable` 的实现要求</title><link>/swift-educational-notes/dynamic-callable-requirements/</link><pubDate>Mon, 13 Jan 2020 02:08:37 +0000</pubDate><guid>/swift-educational-notes/dynamic-callable-requirements/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>诊断名称&lt;/th>
&lt;th>错误信息&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>invalid_&lt;wbr>dynamic_callable_&lt;wbr>type&lt;/code>&lt;/td>
&lt;td>&lt;code>@dynamicCallable&lt;/code> attribute requires &lt;code>X&lt;/code> to have either a valid &lt;code>dynamicallyCall(withArguments:)&lt;/code> method or &lt;code>dynamicallyCall(withKeywordArguments:)&lt;/code> method&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>missing_&lt;wbr>dynamic_callable_&lt;wbr>kwargs_&lt;wbr>method&lt;/code>&lt;/td>
&lt;td>&lt;code>@dynamicCallable&lt;/code> type &lt;code>X&lt;/code> cannot be applied with keyword arguments; missing &lt;code>dynamicCall(withKeywordArguments:)&lt;/code> method&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description><content:encoded><![CDATA[<p>如果用修饰符<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> <code>@dynamicCallable</code> 标记一个类型，那它还必须要实现 <code>dynamicallyCall(withArguments:)</code> 和/或 <code>dynamicallyCall(withKeywordArguments:)</code> 方法，否则会导致编译错误。需要注意的是，必须要实现 <code>dynamicallyCall(withKeywordArguments:)</code> 才能在调用时使用关键字参数/实际参数标签。</p>
<p>有效的 <code>dynamicallyCall(withArguments:)</code> 实现必须：</p>
<ul>
<li>是一个实例方法，而不是 <code>static</code> 或者 <code>class</code> 方法。</li>
<li>接受一个类型遵循 <code>ExpressibleByArrayLiteral</code> 协议的参数——通常这会是 Swift 自带的 <code>Array</code> 类型。</li>
<li>返回一个有效的类型。</li>
</ul>
<p>有效的 <code>dynamicallyCall(withKeywordArguments:)</code> 实现必须：</p>
<ul>
<li>是一个实例方法，而不是 <code>static</code> 或者 <code>class</code> 方法。</li>
<li>接受一个类型遵循 <code>ExpressibleByDictionaryLiteral</code> 协议的参数。这个可以是 <code>Dictionary</code>、<code>KeyValuePairs</code>（用于支持重复的关键字参数）或者其他遵循该协议的类型。</li>
<li>让参数类型的关联类型 <code>Key</code> 遵循 <code>ExpressibleByStringLiteral</code> 协议。这个会是参数关键字的类型。</li>
<li>让参数类型的关联类型 <code>Value</code> 以及返回类型为有效的类型。</li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>attribute，又译作“特性”。 <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><title>闭包类型推断</title><link>/swift-educational-notes/complex-closure-inference/</link><pubDate>Wed, 04 Dec 2019 21:37:11 +0000</pubDate><guid>/swift-educational-notes/complex-closure-inference/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>诊断名称&lt;/th>
&lt;th>错误信息&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>cannot_&lt;wbr>infer_&lt;wbr>closure_&lt;wbr>result_&lt;wbr>type&lt;/code>&lt;/td>
&lt;td>unable to infer [complex] closure return type; add explicit type to disambiguate&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description><content:encoded><![CDATA[<p>如果闭包里只有一个表达式，Swift 会利用闭包的函数体、签名和上下文来进行类型推断。比如下面这段代码里，仅使用 <code>翻倍</code> 的函数体即可将其类型推断为 <code>(Int) -&gt; Int</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="err">翻倍</span> <span class="p">=</span> <span class="p">{</span>
  <span class="nv">$0</span> <span class="o">*</span> <span class="mi">2</span>
<span class="p">}</span>
</code></pre></div><p>但对于不是单个表达式的闭包，其函数体就不会被用于类型推断。这和 Swift 语言其他部分的类型推断方法是一致的：一次处理一条语句。例如下面这段代码就会报错，因为既无法通过 <code>偶数翻倍</code> 的上下文推断类型，也没有提供闭包的签名：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// error: unable to infer complex closure return type; add explicit type to disambiguate</span>
<span class="kd">let</span> <span class="err">偶数翻倍</span> <span class="p">=</span> <span class="p">{</span> <span class="n">x</span> <span class="k">in</span>
  <span class="k">if</span> <span class="n">x</span><span class="p">.</span><span class="n">isMultiple</span><span class="p">(</span><span class="n">of</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>要解决这个问题，我们可以在上下文提供额外的信息：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="err">偶数翻倍</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">=</span> <span class="p">{</span> <span class="n">x</span> <span class="k">in</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div><p>或者写明闭包的签名：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="err">偶数翻倍</span> <span class="p">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="k">in</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>]]></content:encoded></item><item><title>名义类型（nominal type）</title><link>/swift-educational-notes/nominal-types/</link><pubDate>Sat, 02 Nov 2019 20:48:38 +0000</pubDate><guid>/swift-educational-notes/nominal-types/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>诊断名称&lt;/th>
&lt;th>错误信息&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>non_nominal_&lt;wbr>no_&lt;wbr>initializers&lt;/code>&lt;/td>
&lt;td>non-nominal type &lt;code>X&lt;/code> does not support explicit initialization&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>non_nominal_&lt;wbr>extension&lt;/code>&lt;/td>
&lt;td>non-nominal type &lt;code>X&lt;/code> cannot be extended&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>associated_type_&lt;wbr>witness_&lt;wbr>conform_&lt;wbr>impossible&lt;/code>&lt;/td>
&lt;td>candidate can not infer &lt;code>X&lt;/code> = &lt;code>Y&lt;/code> because &lt;code>Y&lt;/code> is not a nominal type and so can&amp;rsquo;t conform to &lt;code>Z&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description><content:encoded><![CDATA[<p>在 Swift 语言中，名义类型（nominal type）是指有名字的类型。换言之，它是在代码里某个地方通过声明这个类型来定义的。举个例子，名义类型包含所有的类、结构体和枚举类型；它们都需要先定义才能使用。而名义类型之所以特别，是因为它们能够被扩展，通过 <code>类型名称()</code> 直接初始化，还能够遵循协议。</p>
<p>任何不是名义类型的类型都是非名义类型（non-nominal type），那它们相对应的也就没有这些功能。因为非名义类型一般是通过组合其他类型得来的，所以偶尔也会被称为结构类型（structural type）。非名义类型包括像 <code>(Int) -&gt; (String)</code> 这样的函数类型、<code>(Int, String)</code> 这样的枚举类型、<code>Int.Type</code> 这样的元类型（metatype）和 <code>Any</code> 以及 <code>AnyObject</code> 这样的特殊类型。</p>
<p>一个协议是否为名义类型，取决于它出现在什么地方。当在被定义，以及像 <code>extension 某个协议 { ... }</code> 这样被扩展时，<code>某个协议</code> 是一个具体的协议类型，因此它是名义类型，可以被扩展、可以遵循协议。然而，当被用作常量或变量的类型时，<code>某个协议</code> 其实替代了一个非名义但实际存在（existential）的类型。这就导致</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">value</span><span class="p">:</span> <span class="err">某个协议</span> <span class="p">=</span> <span class="err">某个协议</span><span class="p">()</span>
</code></pre></div><p>这样的代码是没法编译的。因为在这种情景下 <code>某个协议</code> 是非名义类型，所以它不能被直接初始化。</p>
]]></content:encoded></item></channel></rss>