<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Swift 错误诊断教育文档</title><link>/swift-educational-notes/post/</link><description>Recent content in Posts on Swift 错误诊断教育文档</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2020 Apollo Zhu</copyright><lastBuildDate>Sat, 02 Nov 2019 20:48:38 +0000</lastBuildDate><atom:link href="/swift-educational-notes/post/index.xml" rel="self" type="application/rss+xml"/><item><title>名义类型（nominal type）</title><link>/swift-educational-notes/nominal-types/</link><pubDate>Sat, 02 Nov 2019 20:48:38 +0000</pubDate><guid>/swift-educational-notes/nominal-types/</guid><description>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>诊断名称&lt;/th>
&lt;th>错误信息&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>non_nominal_&lt;/code>&lt;wbr>&lt;code>no_&lt;/code>&lt;wbr>&lt;code>initializers&lt;/code>&lt;/td>
&lt;td>non-nominal type &lt;code>X&lt;/code> does not support explicit initialization&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>non_nominal_&lt;/code>&lt;wbr>&lt;code>extension&lt;/code>&lt;/td>
&lt;td>non-nominal type &lt;code>X&lt;/code> cannot be extended&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>associated_type_&lt;/code>&lt;wbr>&lt;code>witness_&lt;/code>&lt;wbr>&lt;code>conform_&lt;/code>&lt;wbr>&lt;code>impossible&lt;/code>&lt;/td>
&lt;td>candidate can not infer &lt;code>X&lt;/code> = &lt;code>Y&lt;/code> because &lt;code>Y&lt;/code> is not a nominal type and so can&amp;rsquo;t conform to &lt;code>Z&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description><content:encoded><![CDATA[<p>在 Swift 语言中，名义类型（nominal type）是指有名字的类型。换言之，它是在代码里某个地方通过声明这个类型来定义的。举个例子，名义类型包含所有的类、结构体和枚举类型；它们都需要先定义才能使用。而名义类型之所以特别，是因为他们能够被扩展，通过 <code>类型名称()</code> 直接初始化，还能够遵循协议。</p>
<p>任何不是名义类型的类型都是非名义类型（non-nominal type），那它们相对应的也就没有这些功能。因为非名义类型一般是通过组合其他类型得来的，所以偶尔也会被称为结构类型（structural type）。非名义类型包括像 <code>(Int) -&gt; (String)</code> 这样的函数类型、<code>(Int, String)</code> 这样的枚举类型、<code>Int.Type</code> 这样的元类型（metatype）和 <code>Any</code> 以及 <code>AnyObject</code> 这样的特殊类型。</p>
<p>一个协议是否为名义类型，取决于它出现在什么地方。当在被定义，以及像 <code>extension 某个协议 { ... }</code> 这样被扩展时，<code>某个协议</code> 是一个具体的协议类型，因此它是名义类型，可以被扩展、可以遵循协议。然而，当被用作常量或变量的类型时，<code>某个协议</code> 其实替代了一个非名义但实际存在（existential）的类型。这就导致</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="kd">let</span> <span class="nv">value</span><span class="p">:</span> <span class="err">某个协议</span> <span class="p">=</span> <span class="err">某个协议</span><span class="p">()</span>
</code></pre></div><p>这样的代码是没法编译的。因为 <code>某个协议</code> 在这里是个非名义类型，所以它不能在等号右边被直接初始化。</p>
]]></content:encoded></item></channel></rss>